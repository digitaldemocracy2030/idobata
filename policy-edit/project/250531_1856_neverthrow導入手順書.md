# neverthrow導入手順書

## 作成日時
2025年5月31日 18:56

## 概要
チャット機能にneverthrowを導入し、型安全なエラーハンドリングを実現する。
try-catchを使わず、matchを避け、早期リターンパターンを採用する。

## 導入方針

### 基本原則
1. **neverthrowの処理をtry-catchで囲わない**
2. **matchは読み手に負担が大きいから使わない**
3. **エラーは早期リターンする**

### 対象範囲
- `useServerConnection.ts`
- `useChatMessages.ts`
- `useUserManagement.ts`
- API通信層
- データ変換層

## Phase 1: 依存関係とセットアップ

### 1. neverthrowのインストール
```bash
cd frontend
npm install neverthrow
npm install --save-dev @types/neverthrow
```

### 2. エラー型定義の作成

#### `types/errors.ts`
```typescript
// チャット関連のエラー型定義
export type ChatError =
  | NetworkError
  | ApiError
  | ValidationError
  | StateError
  | ParseError;

export interface NetworkError {
  type: 'NETWORK_ERROR';
  message: string;
  cause?: unknown;
}

export interface ApiError {
  type: 'API_ERROR';
  status: number;
  message: string;
  endpoint: string;
}

export interface ValidationError {
  type: 'VALIDATION_ERROR';
  field: string;
  message: string;
}

export interface StateError {
  type: 'STATE_ERROR';
  reason: string;
  context?: Record<string, unknown>;
}

export interface ParseError {
  type: 'PARSE_ERROR';
  message: string;
  data?: unknown;
}

// エラーファクトリー関数
export const createNetworkError = (message: string, cause?: unknown): NetworkError => ({
  type: 'NETWORK_ERROR',
  message,
  cause,
});

export const createApiError = (status: number, message: string, endpoint: string): ApiError => ({
  type: 'API_ERROR',
  status,
  message,
  endpoint,
});

export const createValidationError = (field: string, message: string): ValidationError => ({
  type: 'VALIDATION_ERROR',
  field,
  message,
});

export const createStateError = (reason: string, context?: Record<string, unknown>): StateError => ({
  type: 'STATE_ERROR',
  reason,
  context,
});

export const createParseError = (message: string, data?: unknown): ParseError => ({
  type: 'PARSE_ERROR',
  message,
  data,
});
```

### 3. HttpClientクラスの作成

#### `lib/httpClient.ts`
```typescript
import { Result, ok, err } from 'neverthrow';
import type { ChatError } from '../types/errors';
import { createNetworkError, createApiError, createParseError } from '../types/errors';

export interface RequestConfig extends RequestInit {
  timeout?: number;
}

export class HttpClient {
  private baseUrl: string;
  private defaultTimeout: number;

  constructor(baseUrl: string, defaultTimeout: number = 10000) {
    this.baseUrl = baseUrl.replace(/\/$/, ''); // 末尾のスラッシュを除去
    this.defaultTimeout = defaultTimeout;
  }

  // 基本的なfetch wrapper
  private async safeFetch(
    endpoint: string,
    config: RequestConfig = {}
  ): Promise<Result<Response, ChatError>> {
    const url = `${this.baseUrl}${endpoint}`;
    const timeout = config.timeout ?? this.defaultTimeout;

    // タイムアウト制御
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, {
        ...config,
        signal: controller.signal,
      });
      clearTimeout(timeoutId);
      return ok(response);
    } catch (error) {
      clearTimeout(timeoutId);

      if (error instanceof Error && error.name === 'AbortError') {
        return err(createNetworkError(`Request timeout (${timeout}ms): ${endpoint}`));
      }

      return err(createNetworkError(
        `Network error: ${endpoint}`,
        error
      ));
    }
  }

  // HTTPステータスチェック
  private checkHttpStatus(
    response: Response,
    endpoint: string
  ): Result<Response, ChatError> {
    if (response.ok) {
      return ok(response);
    }

    return err(createApiError(
      response.status,
      `HTTP ${response.status}: ${response.statusText}`,
      endpoint
    ));
  }

  // JSON解析
  private async parseJson<T>(
    response: Response,
    endpoint: string
  ): Promise<Result<T, ChatError>> {
    try {
      const data = await response.json() as T;
      return ok(data);
    } catch (error) {
      return err(createParseError(
        `Failed to parse JSON response from ${endpoint}`,
        error
      ));
    }
  }

  // GET リクエスト
  async get<T>(
    endpoint: string,
    config: RequestConfig = {}
  ): Promise<Result<T, ChatError>> {
    const fetchResult = await this.safeFetch(endpoint, {
      ...config,
      method: 'GET',
    });

    if (fetchResult.isErr()) {
      return err(fetchResult.error);
    }

    const statusResult = this.checkHttpStatus(fetchResult.value, endpoint);
    if (statusResult.isErr()) {
      return err(statusResult.error);
    }

    return this.parseJson<T>(statusResult.value, endpoint);
  }

  // POST リクエスト
  async post<T, U = unknown>(
    endpoint: string,
    data?: U,
    config: RequestConfig = {}
  ): Promise<Result<T, ChatError>> {
    const requestConfig: RequestConfig = {
      ...config,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...config.headers,
      },
    };

    if (data !== undefined) {
      requestConfig.body = JSON.stringify(data);
    }

    const fetchResult = await this.safeFetch(endpoint, requestConfig);

    if (fetchResult.isErr()) {
      return err(fetchResult.error);
    }

    const statusResult = this.checkHttpStatus(fetchResult.value, endpoint);
    if (statusResult.isErr()) {
      return err(statusResult.error);
    }

    return this.parseJson<T>(statusResult.value, endpoint);
  }

  // PUT リクエスト
  async put<T, U = unknown>(
    endpoint: string,
    data?: U,
    config: RequestConfig = {}
  ): Promise<Result<T, ChatError>> {
    const requestConfig: RequestConfig = {
      ...config,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...config.headers,
      },
    };

    if (data !== undefined) {
      requestConfig.body = JSON.stringify(data);
    }

    const fetchResult = await this.safeFetch(endpoint, requestConfig);

    if (fetchResult.isErr()) {
      return err(fetchResult.error);
    }

    const statusResult = this.checkHttpStatus(fetchResult.value, endpoint);
    if (statusResult.isErr()) {
      return err(statusResult.error);
    }

    return this.parseJson<T>(statusResult.value, endpoint);
  }

  // DELETE リクエスト
  async delete<T>(
    endpoint: string,
    config: RequestConfig = {}
  ): Promise<Result<T, ChatError>> {
    const fetchResult = await this.safeFetch(endpoint, {
      ...config,
      method: 'DELETE',
    });

    if (fetchResult.isErr()) {
      return err(fetchResult.error);
    }

    const statusResult = this.checkHttpStatus(fetchResult.value, endpoint);
    if (statusResult.isErr()) {
      return err(statusResult.error);
    }

    return this.parseJson<T>(statusResult.value, endpoint);
  }

  // レスポンスボディなしのリクエスト（ステータスコードのみチェック）
  async request(
    endpoint: string,
    config: RequestConfig = {}
  ): Promise<Result<void, ChatError>> {
    const fetchResult = await this.safeFetch(endpoint, config);

    if (fetchResult.isErr()) {
      return err(fetchResult.error);
    }

    const statusResult = this.checkHttpStatus(fetchResult.value, endpoint);
    if (statusResult.isErr()) {
      return err(statusResult.error);
    }

    return ok(undefined);
  }
}

// シングルトンインスタンス
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || "http://localhost:3001/api";
export const httpClient = new HttpClient(API_BASE_URL);
```

### 4. ApiClientクラスの作成（ドメイン固有）

#### `lib/apiClient.ts`
```typescript
import { Result, ok, err } from 'neverthrow';
import type { ChatError } from '../types/errors';
import type { OpenAIMessage } from '../types/chat';
import { createValidationError } from '../types/errors';
import { httpClient } from './httpClient';

// API レスポンス型定義
interface ConnectionStatus {
  initialized: boolean;
}

interface ChatResponse {
  response: string;
}

// API リクエスト型定義
export interface ChatPayload {
  message: string;
  history: OpenAIMessage[];
  branchId: string;
  fileContent: string | null;
  userName: string;
  filePath: string;
}

// バリデーション関数
const validateChatPayload = (payload: ChatPayload): Result<ChatPayload, ChatError> => {
  if (!payload.message.trim()) {
    return err(createValidationError('message', 'メッセージが空です'));
  }

  if (!payload.userName.trim()) {
    return err(createValidationError('userName', 'ユーザー名が設定されていません'));
  }

  if (!payload.filePath.trim()) {
    return err(createValidationError('filePath', 'ファイルパスが設定されていません'));
  }

  return ok(payload);
};

export class ApiClient {
  // 接続ステータス確認
  async checkConnectionStatus(): Promise<Result<boolean, ChatError>> {
    const result = await httpClient.get<ConnectionStatus>('/chat/status');

    if (result.isErr()) {
      return err(result.error);
    }

    return ok(result.value.initialized);
  }

  // サーバー接続
  async connectToServer(): Promise<Result<void, ChatError>> {
    const result = await httpClient.request('/chat/connect', {
      method: 'POST',
    });

    if (result.isErr()) {
      return err(result.error);
    }

    return ok(undefined);
  }

  // チャットメッセージ送信
  async postChatMessage(payload: ChatPayload): Promise<Result<string, ChatError>> {
    const validationResult = validateChatPayload(payload);
    if (validationResult.isErr()) {
      return err(validationResult.error);
    }

    const result = await httpClient.post<ChatResponse, ChatPayload>('/chat', payload);

    if (result.isErr()) {
      return err(result.error);
    }

    return ok(result.value.response);
  }
}

// シングルトンインスタンス
export const apiClient = new ApiClient();
```

### 4. ユーティリティ関数の作成

#### `utils/resultUtils.ts`
```typescript
import type { ChatError } from '../types/errors';

// エラーメッセージの統一変換
export const formatErrorMessage = (error: ChatError): string => {
  switch (error.type) {
    case 'NETWORK_ERROR':
      return `ネットワークエラー: ${error.message}`;
    case 'API_ERROR':
      return `APIエラー (${error.status}): ${error.message}`;
    case 'VALIDATION_ERROR':
      return `入力エラー (${error.field}): ${error.message}`;
    case 'STATE_ERROR':
      return `状態エラー: ${error.reason}`;
    case 'PARSE_ERROR':
      return `データ解析エラー: ${error.message}`;
    default:
      return '不明なエラーが発生しました';
  }
};
```

## Phase 2: API層のリファクタリング

### 1. サーバー接続API

#### `services/connectionService.ts`
```typescript
import { Result } from 'neverthrow';
import type { ChatError } from '../types/errors';
import { apiClient } from '../lib/apiClient';

export const checkConnectionStatus = async (): Promise<Result<boolean, ChatError>> => {
  return apiClient.checkConnectionStatus();
};

export const connectToServer = async (): Promise<Result<void, ChatError>> => {
  return apiClient.connectToServer();
};
```

### 2. チャットメッセージAPI

#### `services/chatService.ts`
```typescript
import { Result } from 'neverthrow';
import type { ChatError } from '../types/errors';
import { apiClient, type ChatPayload } from '../lib/apiClient';

export const sendChatMessage = async (payload: ChatPayload): Promise<Result<string, ChatError>> => {
  return apiClient.postChatMessage(payload);
};
```

## Phase 3: フック層のリファクタリング

### 1. useServerConnection の改修

#### `hooks/useServerConnection.ts`
```typescript
import { useCallback, useEffect, useState } from "react";
import { Result } from 'neverthrow';
import type { ChatError } from '../types/errors';
import { checkConnectionStatus, connectToServer } from '../services/connectionService';
import { formatErrorMessage } from '../utils/resultUtils';

export interface UseServerConnectionReturn {
  isConnected: boolean;
  isLoading: boolean;
  error: string | null;
  connect: () => Promise<Result<void, ChatError>>;
  checkStatus: () => Promise<Result<boolean, ChatError>>;
}

export function useServerConnection(): UseServerConnectionReturn {
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const checkStatus = useCallback(async (): Promise<Result<boolean, ChatError>> => {
    const result = await checkConnectionStatus();

    if (result.isErr()) {
      setIsConnected(false);
      setError(formatErrorMessage(result.error));
      return result;
    }

    setIsConnected(result.value);
    setError(null);
    return result;
  }, []);

  const connect = useCallback(async (): Promise<Result<void, ChatError>> => {
    setIsLoading(true);
    setError(null);

    const result = await connectToServer();

    if (result.isErr()) {
      setError(formatErrorMessage(result.error));
      setIsLoading(false);
      return result;
    }

    setIsConnected(true);
    setIsLoading(false);
    return result;
  }, []);

  const initializeConnection = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    const statusResult = await checkStatus();
    if (statusResult.isErr()) {
      setIsLoading(false);
      return;
    }

    if (!statusResult.value) {
      console.log("Not connected, attempting auto-connection...");
      const connectResult = await connect();
      if (connectResult.isErr()) {
        console.error("初期接続に失敗:", connectResult.error);
      }
    } else {
      console.log("マウント時に既に接続されています。");
      setIsLoading(false);
    }
  }, [checkStatus, connect]);

  useEffect(() => {
    initializeConnection();
  }, [initializeConnection]);

  return {
    isConnected,
    isLoading,
    error,
    connect,
    checkStatus,
  };
}
```

### 2. useChatMessages の改修

#### `hooks/useChatMessages.ts`
```typescript
import { useCallback, useState } from "react";
import { Result } from 'neverthrow';
import type { GitHubFile } from "../lib/github";
import { decodeBase64Content } from "../lib/github";
import useContentStore from "../store/contentStore";
import type { OpenAIMessage, ChatError } from "../types/chat";
import { prepareChatHistory } from "../utils/chatUtils";
import { sendChatMessage } from "../services/chatService";
import { formatErrorMessage } from "../utils/resultUtils";
import { createStateError } from "../types/errors";

export interface UseChatMessagesReturn {
  sendMessage: (message: string, userName: string) => Promise<Result<void, ChatError>>;
  isLoading: boolean;
  error: string | null;
}

export function useChatMessages(): UseChatMessagesReturn {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const {
    currentPath,
    contentType,
    content,
    chatThreads,
    addMessageToThread,
    ensureBranchIdForThread,
    reloadCurrentContent,
  } = useContentStore();

  const sendMessage = useCallback(async (
    userInput: string,
    userName: string
  ): Promise<Result<void, ChatError>> => {
    // 早期リターンパターン
    if (!currentPath) {
      const error = createStateError("現在のパスが設定されていません");
      setError(formatErrorMessage(error));
      return err(error);
    }

    const currentThread = chatThreads[currentPath];
    if (!currentThread) {
      const error = createStateError("チャットスレッドが見つかりません");
      setError(formatErrorMessage(error));
      return err(error);
    }

    const currentBranchId = ensureBranchIdForThread(currentPath);

    // ユーザーメッセージを即座に追加
    addMessageToThread(currentPath, {
      text: userInput,
      sender: "user",
    });

    setIsLoading(true);
    setError(null);

    // ファイルコンテンツの準備
    let fileContent: string | null = null;
    if (contentType === "file" && content && "content" in content) {
      try {
        fileContent = decodeBase64Content((content as GitHubFile).content);
      } catch (e) {
        console.error("ファイルコンテンツのデコードに失敗しました:", e);
      }
    }

    const payload = {
      message: userInput,
      history: prepareChatHistory(currentThread.messages),
      branchId: currentBranchId,
      fileContent: fileContent,
      userName: userName,
      filePath: currentPath,
    };

    const result = await sendChatMessage(payload);

    if (result.isErr()) {
      const errorMsg = formatErrorMessage(result.error);
      setError(errorMsg);
      addMessageToThread(currentPath, {
        text: `エラー：${errorMsg}`,
        sender: "bot",
      });
      setIsLoading(false);
      return result;
    }

    // 成功時の処理
    addMessageToThread(currentPath, {
      text: result.value,
      sender: "bot"
    });

    console.log("ボットの応答を受信しました。コンテンツを再読み込みしています...");
    reloadCurrentContent();
    setIsLoading(false);

    return ok(undefined);
  }, [
    currentPath,
    contentType,
    content,
    chatThreads,
    addMessageToThread,
    ensureBranchIdForThread,
    reloadCurrentContent,
  ]);

  return {
    sendMessage,
    isLoading,
    error,
  };
}
```

## Phase 4: UI層の対応

### 1. useChatController の改修

#### `hooks/useChatController.ts`
```typescript
import { useCallback, useMemo, useState } from "react";
import { Result } from 'neverthrow';
import useContentStore from "../store/contentStore";
import type { ChatMessage, ChatThread, ChatError } from "../types/chat";
import { useChatMessages } from "./useChatMessages";
import { useServerConnection } from "./useServerConnection";
import { useUserManagement } from "./useUserManagement";

export interface UseChatControllerReturn {
  isChatEnabled: boolean;
  currentThread: ChatThread | null;
  messages: ChatMessage[];

  connection: {
    isConnected: boolean;
    isLoading: boolean;
    error: string | null;
    connect: () => Promise<Result<void, ChatError>>;
  };

  messageHandler: {
    isLoading: boolean;
    error: string | null;
  };

  userManager: {
    userName: string | null;
    promptForName: () => Promise<string>;
  };

  inputValue: string;
  setInputValue: (value: string) => void;
  handleSendMessage: () => Promise<void>;
  handleKeyDown: (event: React.KeyboardEvent<HTMLTextAreaElement>) => void;
  addBotMessageToCurrentThread: (text: string) => void;
}

export function useChatController(): UseChatControllerReturn {
  const [inputValue, setInputValue] = useState("");

  const {
    currentPath,
    contentType,
    chatThreads,
    getOrCreateChatThread,
    addMessageToThread,
  } = useContentStore();

  const connection = useServerConnection();
  const messageHandler = useChatMessages();
  const userManager = useUserManagement();

  const isChatEnabled = useMemo(() => {
    return contentType === "file" && currentPath.endsWith(".md");
  }, [contentType, currentPath]);

  const currentThread = useMemo(() => {
    if (isChatEnabled) {
      return getOrCreateChatThread(currentPath);
    }
    return null;
  }, [isChatEnabled, currentPath, chatThreads, getOrCreateChatThread]);

  const messages = useMemo(() => {
    return currentThread?.messages ?? [];
  }, [currentThread]);

  const addBotMessageToCurrentThread = useCallback((text: string) => {
    if (isChatEnabled && currentPath) {
      addMessageToThread(currentPath, { text, sender: "bot" });
    } else {
      console.warn(
        "アクティブなMDファイルがないときにボットメッセージを追加しようとしました。"
      );
    }
  }, [isChatEnabled, currentPath, addMessageToThread]);

  const handleSendMessage = useCallback(async () => {
    // 早期リターンパターン
    if (inputValue.trim() === "") return;
    if (!isChatEnabled) return;
    if (!currentPath) return;
    if (!currentThread) return;

    let userName = userManager.userName;
    if (!userName) {
      userName = await userManager.promptForName();
    }

    const userInput = inputValue;
    setInputValue("");

    const result = await messageHandler.sendMessage(userInput, userName);
    if (result.isErr()) {
      console.error("メッセージ送信エラー:", result.error);
    }
  }, [
    inputValue,
    isChatEnabled,
    currentPath,
    currentThread,
    userManager,
    messageHandler,
  ]);

  const handleKeyDown = useCallback((event: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (
      event.key === "Enter" &&
      !event.shiftKey &&
      !event.nativeEvent.isComposing
    ) {
      event.preventDefault();
      handleSendMessage();
    }
  }, [handleSendMessage]);

  return {
    isChatEnabled,
    currentThread,
    messages,
    connection: {
      isConnected: connection.isConnected,
      isLoading: connection.isLoading,
      error: connection.error,
      connect: connection.connect,
    },
    messageHandler: {
      isLoading: messageHandler.isLoading,
      error: messageHandler.error,
    },
    userManager: {
      userName: userManager.userName,
      promptForName: userManager.promptForName,
    },
    inputValue,
    setInputValue,
    handleSendMessage,
    handleKeyDown,
    addBotMessageToCurrentThread,
  };
}
```

## Phase 5: 実装手順

### 1. 準備作業
1. neverthrowのインストール
2. 型定義ファイルの作成
3. ユーティリティ関数の作成

### 2. 段階的移行
1. **API層**: connectionService.ts, chatService.ts
2. **フック層**: useServerConnection.ts, useChatMessages.ts
3. **統合層**: useChatController.ts
4. **UI層**: 必要に応じて調整

### 3. テスト戦略
1. 各サービス関数のユニットテスト
2. エラーケースの網羅的テスト
3. 統合テストでのエラーフロー確認

## 期待される効果

### 1. 型安全性の向上
- エラーの種類が明確に定義される
- コンパイル時にエラーハンドリングの漏れを検出

### 2. 可読性の向上
- 早期リターンパターンによる直線的なコード
- matchを使わないシンプルな分岐

### 3. 保守性の向上
- エラーハンドリングの統一
- エラーメッセージの一元管理

### 4. デバッグの容易さ
- エラーの発生箇所と種類が明確
- ログ出力の統一

## 注意事項

1. **try-catchは使用しない**: neverthrowのResult型で全て処理
2. **matchは避ける**: isErr()とisOk()で分岐
3. **早期リターン**: エラー時は即座にreturn
4. **段階的移行**: 一度に全てを変更せず、機能単位で移行

## ApiClientクラス導入の追加恩恵

### 1. コードの簡潔性
#### Before（従来のfetch）
```typescript
// 10行以上のボイラープレート
try {
  const response = await fetch(`${API_BASE_URL}/chat/status`);
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
  const data = await response.json();
  return ok(data.initialized);
} catch (error) {
  return err(createNetworkError('Failed to fetch', error));
}
```

#### After（ApiClient + neverthrow）
```typescript
// 1行でエラーハンドリング込み
const result = await apiClient.get<ConnectionStatus>('/chat/status');
if (result.isErr()) return err(result.error);
return ok(result.value.initialized);
```

### 2. 統一されたHTTP通信
- **タイムアウト制御**: デフォルト10秒、カスタマイズ可能
- **エラーハンドリングの統一**: ネットワーク、HTTP、パースエラーを統一処理
- **型安全なAPI呼び出し**: ジェネリクスによる型推論
- **テスタビリティ**: モック化が容易
- **拡張性**: 認証ヘッダーやインターセプターの追加が容易

### 3. 期待される効果の総括

#### 型安全性の向上
- エラーの種類が明確に定義される
- コンパイル時にエラーハンドリングの漏れを検出
- ApiClientによる型推論の活用

#### 可読性の向上
- 早期リターンパターンによる直線的なコード
- matchを使わないシンプルな分岐
- ApiClientによる簡潔なAPI呼び出し

#### 保守性の向上
- エラーハンドリングの統一
- エラーメッセージの一元管理
- HTTP通信ロジックの一元化

#### デバッグの容易さ
- エラーの発生箇所と種類が明確
- ログ出力の統一
- タイムアウト制御の統一

## 注意事項

1. **try-catchは使用しない**: neverthrowのResult型で全て処理
2. **matchは避ける**: isErr()とisOk()で分岐
3. **早期リターン**: エラー時は即座にreturn
4. **段階的移行**: 一度に全てを変更せず、機能単位で移行
5. **ApiClientの活用**: 低レベルなfetch操作は避け、ApiClientを使用
